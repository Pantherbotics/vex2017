#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyroscope,      sensorGyro)
#pragma config(Sensor, dgtl1,  solExtend,      sensorDigitalOut)
#pragma config(Sensor, dgtl2,  solDeployA,     sensorDigitalOut)
#pragma config(Sensor, dgtl3,  solDeployB,     sensorDigitalOut)
#pragma config(Sensor, dgtl4,  solDeployC,     sensorDigitalOut)
#pragma config(Sensor, I2C_1,  encFrontRight,  sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  encBackRight,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  encIntake,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  encCenter,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  encBackLeft,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_6,  encFrontLeft,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           drCenterA,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           drFrontLeft,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           drBackLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           inChainA,      tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           inChainC,      tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           drFrontRight,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           drBackRight,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           inChainB,      tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           inChainD,      tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          drCenterB,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"


//----------------Joystick Mappings----------------//
#define joyForward Ch3
#define joyStrafe Ch1
#define joyLeftTurnF Btn5U
#define joyLeftTurnS Btn5D
#define joyRightTurnF Btn6U
#define joyRightTurnS Btn6D

#define joyExtend Btn7U
#define joyDeployA Btn7R
#define joyDeployB Btn7L
#define joyDeployC Btn7D

//------------------Motor Inverts------------------//
// Drive
#define mInvertCenterA 1
#define mInvertCenterB 1
#define mInvertFrontLeft 1
#define mInvertFrontRight -1
#define mInvertBackLeft -1
#define mInvertBackRight -1

//Intake
#define mInvertChainA 1
#define mInvertChainB 1
#define mInvertChainC 1
#define mInvertChainD 1

//--------------------Constants--------------------//
const float deadzoneJoyForward = 1.5;
const float deadzoneJoyStrafe = 1.5;

void manualPistonTriggers () {
  SensorValue[solExtend] = vexRT[joyExtend];
  SensorValue[solDeployA] = vexRT[joyDeployA];
  SensorValue[solDeployB] = vexRT[joyDeployB];
  SensorValue[solDeployC] = vexRT[joyDeployC];
}

void setIntakeMotors (int speed) {
  motor[inChainA] = speed;
  motor[inChainB] = speed * -1; //A and B are opposite mechanically linked by axel
  motor[inChainC] = speed * -1; //A and C are opposite mechanically linked by gear
  motor[inChainD] = speed;      //C and D are opposite mechanically linked by axel
}


void setDriveMotors(int fL, int fR, int bL, int bR,int cn) {
  motor[drFrontRight] = fL * mInvertFrontRight;
  motor[drFrontLeft]  = fR * mInvertFrontLeft;
  motor[drBackLeft]   = bL * mInvertBackLeft;
  motor[drBackRight]  = bR * mInvertBackRight;
  motor[drCenterA]    = cn * mInvertCenterA;
  motor[drCenterB]    = cn * mInvertCenterB * -1;
}
void driveOnControllerInput () {
    //Vertical Left Josystick - Forward/Back
    //Horizontal Right Joystick - Left/Right
    //Trigger Up - Fast Turn
    //Trigger Down - Slow Turn

  //NOTE: 'Forward' on robot is oriented 'left' in respect to motors (90deg counterclockwise shift)
  int rawStr = vexRT[joyStrafe];
  int rawFwd = -vexRT[joyForward];
  int smthFwd = 0;
  int smthStr = 0;

  //Deadzone calculations
  if (rawStr > deadzoneJoyStrafe || rawStr < -deadzoneJoyStrafe){
    smthStr = rawStr;
  }else{
    smthStr = 0;
  }

  if (rawFwd > deadzoneJoyForward || rawFwd < -deadzoneJoyForward){
    smthFwd = rawFwd;
  }else{
    smthFwd = 0;
  }

  if (vexRT[joyLeftTurnS] || vexRT[joyLeftTurnF]) {
  	int str=50*vexRT[joyLeftTurnS]+90*vexRT[joyLeftTurnF];
  	setDriveMotors(str,-str,-str,str,0);

  }else if (vexRT[joyRightTurnS] || vexRT[joyRightTurnF]){
  	int str=50*vexRT[joyRightTurnS]+90*vexRT[joyRightTurnF];
  	setDriveMotors(-str,str,str,-str,0);

  } else{
    setDriveMotors(smthStr + smthFwd,   //FrontLeft
                   smthStr + smthFwd,   //FrontRight
                   smthStr - smthFwd ,  //BackLeft
                   smthStr - smthFwd,   //BackRight
                   smthStr);             //Center
  }
}

void deployNet (){

  SensorValue[solExtend] = 1;
  wait1Msec(100);

  //Retract alignment solenoids
  SensorValue[solDeployA] = 1;
  SensorValue[solDeployB] = 1;
  SensorValue[solDeployC] = 1;
  wait1Msec(100);
  setDriveMotors(50,50,-50,-50,0);
  wait1Msec(750);
  setDriveMotors(-127,-127,-127,-127,-127);
  wait1Msec(1000);
  setDriveMotors(-50,-50,50,50,0);
  wait1Msec(750);
  setDriveMotors(-127,-127,-127,-127,-127);
  wait1Msec(5000);
  setDriveMotors(0,0,0,0,0);


}

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// bDisplayCompetitionStatusOnLcd = false;
}

task autonomous(){
  // Remove this function call once you have "real" code.
  AutonomousCodePlaceholderForTesting();
}

task usercontrol(){
  // User control code here, inside the loop
  SensorValue[encFrontLeft] = 0;
  SensorValue[encFrontRight] = 0;
  SensorValue[encBackLeft] = 0;
  SensorValue[encBackRight] = 0;
  SensorValue[encCenter] = 0;
  while (true) {
   driveOnControllerInput ();
   manualPistonTriggers ();
   writeDebugStreamLine("FL: %i FR: %i BL: %i BR: %i CE: %i",SensorValue[encFrontLeft]*mInvertFrontLeft, SensorValue[encFrontRight]*mInvertFrontRight, SensorValue[encBackLeft]*mInvertBackLeft, SensorValue[encBackRight]*mInvertBackRight, SensorValue[encCenter]*mInvertCenterA);
   wait1Msec(100);

   if (vexRT[Btn8U]){deployNet();}
  }
}
