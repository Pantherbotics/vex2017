#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyroscope,      sensorGyro)
#pragma config(Sensor, dgtl1,  solExtend,      sensorDigitalOut)
#pragma config(Sensor, dgtl2,  solDeployA,     sensorDigitalOut)
#pragma config(Sensor, dgtl3,  solDeployB,     sensorDigitalOut)
#pragma config(Sensor, dgtl4,  solDeployC,     sensorDigitalOut)
#pragma config(Sensor, I2C_1,  encFrontRight,  sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  encBackRight,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  encIntake,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  encCenter,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  encBackLeft,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_6,  encFrontLeft,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           drCenterA,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           drFrontLeft,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           drBackLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           inChainA,      tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           inChainC,      tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           drFrontRight,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           drBackRight,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           inChainB,      tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           inChainD,      tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          drCenterB,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"


//----------------Joystick Mappings----------------//
#define joyForward Ch3
#define joyStrafe Ch1
#define joyLeftTurnF Btn5U
#define joyLeftTurnS Btn5D
#define joyRightTurnF Btn6U
#define joyRightTurnS Btn6D

#define joyExtend Btn7U
#define joyDeployA Btn7R
#define joyDeployB Btn7L
#define joyDeployC Btn7D

//------------------Motor Inverts------------------//
// Drive
#define mInvertCenterA 1
#define mInvertCenterB 1
#define mInvertFrontLeft 1
#define mInvertFrontRight -1
#define mInvertBackLeft -1
#define mInvertBackRight -1

//Intake
#define mInvertChainA 1
#define mInvertChainB 1
#define mInvertChainC 1
#define mInvertChainD 1

//--------------------Constants--------------------//
const float deadzoneJoyForward = 1.5;
const float deadzoneJoyStrafe = 1.5;

//Variables/
int targetAngle = 0;

void manualPistonTriggers () {
  SensorValue[solExtend] = vexRT[joyExtend];
  SensorValue[solDeployA] = vexRT[joyDeployA];
  SensorValue[solDeployB] = vexRT[joyDeployB];
  SensorValue[solDeployC] = vexRT[joyDeployC];
}

void setAngleTargetAsCurrent(){
  targetAngle = SensorValue[gyroscope];
}
void setIntakeMotors (int speed) {
  motor[inChainA] = speed;
  motor[inChainB] = speed * -1; //A and B are opposite mechanically linked by axel
  motor[inChainC] = speed * -1; //A and C are opposite mechanically linked by gear
  motor[inChainD] = speed;      //C and D are opposite mechanically linked by axel
}

void setMotorPID(int target, tMotor motorID, int encoderID){
  motor[motorID] = target;

  if (motorID == drFrontRight){
    writeDebugStreamLine("%i", SensorValue[gyroscope]);
  }
}


void setDriveMotors(int fL, int fR, int bL, int bR,int cn) {
  setMotorPID(fL * mInvertFrontRight, drFrontRight, encFrontRight);
  setMotorPID(fR * mInvertFrontLeft, drFrontLeft, encFrontLeft);
  setMotorPID(bL * mInvertBackLeft, drBackLeft, encBackLeft);
  setMotorPID(bR * mInvertBackRight, drBackRight, encBackRight);
  setMotorPID(cn * mInvertCenterA, drCenterA, encCenter);
  setMotorPID(cn * mInvertCenterB * -1, drCenterB, encCenter * -1);
}

void driveOnControllerInput () {
    //Vertical Left Josystick - Forward/Back
    //Horizontal Right Joystick - Left/Right
    //Trigger Up - Fast Turn
    //Trigger Down - Slow Turn

  //NOTE: 'Forward' on robot is oriented 'left' in respect to motors (90deg counterclockwise shift)
  int rawStr = vexRT[joyStrafe];
  int rawFwd = -vexRT[joyForward];
  int smthFwd = 0;
  int smthStr = 0;

  //Deadzone calculations
  if (rawStr > deadzoneJoyStrafe || rawStr < -deadzoneJoyStrafe){
    smthStr = rawStr;
  }else{
    smthStr = 0;
  }

  if (rawFwd > deadzoneJoyForward || rawFwd < -deadzoneJoyForward){
    smthFwd = rawFwd;
  }else{
    smthFwd = 0;
  }

  if (vexRT[joyLeftTurnS] || vexRT[joyLeftTurnF]) {
  	int str=50*vexRT[joyLeftTurnS]+90*vexRT[joyLeftTurnF];
  	setDriveMotors(str,-str,-str,str,0);

  }else if (vexRT[joyRightTurnS] || vexRT[joyRightTurnF]){
  	int str=50*vexRT[joyRightTurnS]+90*vexRT[joyRightTurnF];
  	setDriveMotors(-str,str,str,-str,0);

  } else{
    float gyroDiff = (SensorValue[gyroscope] - targetAngle) * 0.3;
    setDriveMotors(smthStr + smthFwd - gyroDiff,   //FrontLeft
                   smthStr + smthFwd + gyroDiff,   //FrontRight
                   smthStr - smthFwd + gyroDiff,  //BackLeft
                   smthStr - smthFwd - gyroDiff,   //BackRight
                   smthStr);             //Center
  }
}

void deployNet (){

  SensorValue[solExtend] = 1;
  wait1Msec(100);

  //Retract alignment solenoids
  SensorValue[solDeployA] = 1;
  SensorValue[solDeployB] = 1;
  SensorValue[solDeployC] = 1;
  wait1Msec(100);
  setDriveMotors(50,50,-50,-50,0);
  wait1Msec(750);
  setDriveMotors(-127,-127,-127,-127,-127);
  wait1Msec(1000);
  setDriveMotors(-50,-50,50,50,0);
  wait1Msec(750);
  setDriveMotors(-127,-127,-127,-127,-127);
  wait1Msec(5000);
  setDriveMotors(0,0,0,0,0);


}

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// bDisplayCompetitionStatusOnLcd = false;

}

task autonomous(){
  // Remove this function call once you have "real" code.
  AutonomousCodePlaceholderForTesting();
}

task usercontrol(){
  // User control code here, inside the loop
  SensorValue[encFrontLeft] = 0;
  SensorValue[encFrontRight] = 0;
  SensorValue[encBackLeft] = 0;
  SensorValue[encBackRight] = 0;
  SensorValue[encCenter] = 0;

   //Completely clear out any previous sensor readings by setting the port to "sensorNone"
 SensorType[gyroscope] = sensorNone;
 wait1Msec(1000);
 //Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
 SensorType[gyroscope] = sensorGyro;
 wait1Msec(2000);
 
//Adjust SensorScale to correct the scaling for your gyro
 //SensorScale[gyroscope] = 260;
 //Adjust SensorFullCount to set the "rollover" point. 3600 sets the rollover point to +/-3600
 SensorFullCount[gyroscope] = 36000;

  while (true) {
   driveOnControllerInput ();
   manualPistonTriggers ();

   if (vexRT[Btn8U]){setAngleTargetAsCurrent();}
  }

  wait1Msec(50);

}
